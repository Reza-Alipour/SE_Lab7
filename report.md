# گزارش آزمایش
## الگوی Facade
الگوی Facade یک الگوی طراحی نرم‌افزاری است که معمولاً در برنامه‌نویسی شی‌گرا استفاده می‌شود. براساس این الگو، ارتباط قسمتی از کد با محیط از طریق یک کلاس facade انجام می‌شود. به این شکل برای هرکدام از packageهای کد می‌توان یک کلاس facade تعریف کرد که از طریق آن با بقیه packageها ارتباط برقرار می‌کنند. در نتیجه‌ی این کار، پیچیدگی روابط بین اجزا کاهش پیدا می‌کند و اگر بخشی از برنامه تغییر کند، راحت‌تر می‌توان بقیه اجزا را با آن سازگار کرد. 
در کلاس CodeGenerator توابع semanticFunction، pid، kpid و intpid دچار تغییرات جزئی شده‌اند. در کلاس CodeGeneratorFacade تابع semanticFunction دچار یک تغییر کوچک شده است. در کلاس ParseTable تغییراتی در constructoe صورت گرفته است. در کلاس Rule و GrammerSymbol نیز تغییراتی انجام گرفته است. کلاس‌های CodeGeneratorFacade , ScannerFacade و IToken ، IAddress و IMemory نیز اضافه شده اند. مشابه تغییرات فوق در package CodeGenerator نیز انجام گرفته است.
## الگو Replace Conditional with Polymorphism 
در این الگو به جای اینکه از شرط برای مشخص کردن عملیات مربوط به اشیای مختلف استفاده کنیم، برای هر نوع شی یک کلاس فرزند ایجاد می‌کنیم که عملیات مربوطه را با رونویسی تابع اصلی انجام دهد.

کلاس‌های AcceptAct، ReduceAct و ShiftAct به عنوان فرزندان کلاس Act ساخته شده‌اند که متد actionToString را رونویسی می‌کنند. در کلاس Action متد toString تغییر کرده و همچنین enum act از آن حذف شده و به شکل یک کلاس انتزاعی درآمده است. در کلاس Parser متد startParse تغییرات زیادی داشته و کلاس ParseTable نیز به شکل جزئی تغییر کرده.
## الگو Separate Query From Modifier
همانطور که از اسم آن مشخص است، در این الگو قسمت‌هایی از کد که داده‌ها را دریافت می‌کند (کوئری) از قسمت‌های کد که داده‌ها را تغییر می‌دهد جدا شده است.

در فایل codeGenerator.java توابع زیادی از جمله add ، sub، equal و and تغییر جزئی داشته‌اند. متد getTemp از کلاس Memory تغییر کرده و updateTempIndex اضافه شده است.
## الگو Self Encapsulate Field
در این الگو فیلدهای اشیا به حالت private در می‌آید و دسترسی به آن‌ها تنها از طریق توابع setter و Getter ممکن می‌شود. به این شکل دسترسی کلاس‌های بیرونی به این مولفه‌ها محدود می‌شود.

در کلاس Token توابع toString، equals، hashCode دچار تغییر می‌شوند و تابع getType نیز به این کلاس اضافه می‌شود.

# پرسش‌ها
## سوال 1
### کد تمیز
کدی تمیز است که برای برنامه‌نویسان دیگر که شناختی از جزئیات پروژه ندارند، به راحتی قابل درک و بررسی باشد. یعنی از روی این کدها بتوانند به عملکرد بخش‌های پروژه پی ببرند.
### بدهی فنی
مواردی که برنامه‌نویسان به دلایلی یک کد غیرتمیز مینویسند که در کوتاه مدت سرعت آن‌ها را افزایش می‌دهد، اما در بلندمدت باید زمان بیشتری صرف درک و بررسی آن داشته باشند.
### بوی بد!!
در نتیجه‌ی برنامه‌نویسی نادرست ویژگی‌هایی در کد منبع یک برنامه ایجاد می‌شود که نشان‌دهنده مشکلات عمیق‌تری است.

## سوال 2
### مورد Bloaters:
این کدها کلاس‌ها و متدهایی هستند که به اندازه‌ای بزرگ شده‌اند که کار کردن با آنها سخت است. معمولاً این موارد زود ظاهر نمی‌شوند و در طول زمان و با تکامل برنامه انباشته می‌شوند.
### مورد Object-Oriented Abusers:
مواردی هستند که از کاربرد ناقص یا نادرست اصول برنامه‌نویسی شی‌گرا به وجود می‌آیند.
### مورد Change Preventers:
مواردی که اگر نیاز به تغییر بخشی از کد برنامه باشد، بدلیل همبستگی بین بخش‌ها، باید در جاهای دیگر برنامه نیز تغییراتی ایجاد شود. در نتیجه توسعه و نگهداری کد سخت‌تر می‌شود.
### مورد Dispensables:
بخشی از کد برنامه است که اضافه است و در صورت حذف آن کد ساده‌تر و بهینه‌تر خواهد بود.
### مورد Couplers:
مواردی هستند که باعث همبستگی بیش از حد کلاس‌ها می‌شوند یا نشان می‌دهند که اگر به جای همبستگی تا حد ممکن کارها به خود کلاس‌ها داده شود، چه اتفاقی می‌افتد.

## سوال 3
در دسته‌ی Dispensables قرار می‌گیرد.

برای برطرف کردن این مشکل از بازآرایی‌های Inline Class و Collapse Hierarchy استفاده می‌شود. مورد اول برای زمانی است که اجزایی از سیستم تقریبا بی‌استفاده هستند. در این مواقع توابع مورد نیاز از آن‌ها را در قالب یک کلاس درونی در یک کلاس دیگر قرار می‌دهیم. مورد دوم برای زمانی است که کلاس درونی دارای توابع اندکی است که در این هنگام بهتر است با کلاس بیرونی ترکیب شود.

گاهی اوقات یک lazy class به منظور ترسیم اهداف توسعه آینده ایجاد میشود. در این مورد، با ایجاد تعادلی بین وضوح و سادگی در کد، بهتر است از این مشکل صرف نظر کنیم. 
